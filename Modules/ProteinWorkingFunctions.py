from Bio.PDB import PDBIO, PPBuilder, Superimposer, PDBList, NeighborSearch, Selection
from . import GeneralFunctions, FileParsersGenerators
import copy
import numpy
import sys

def SelectTemplate(BLAST_outs):
	"""
	Selects the best templates from the BLAST output for all chains.

	Arguments:

	BLAST_outs: list of output file names generated by BLAST.
	"""

	Outputs = {}

	for Out in BLAST_outs:
		BLAST_out = open(Out)
		First = True
		for line in BLAST_out:
			if line.startswith("Sequences producing significant alignments:"):
				BLAST_out.readline()
				for line in BLAST_out:
					line = line.strip()
					line = line.split()
					if First:
						min_evalue = line[len(line)-1]
						template_evalue = [(GeneralFunctions.GetNameWOChain(line[0]), line[len(line)-1])]
						Outputs[Out] = template_evalue
						First = False
					else:
						if line[len(line)-1] == min_evalue:
							template_evalue.append((GeneralFunctions.GetNameWOChain(line[0]), line[len(line)-1]))
							Outputs[Out] = template_evalue
						else:
							break
	# Select all possible best templates, the ones with the minimum evalue.
	min_evalue = min(map(lambda x: min(map(lambda y: y[1], x)), Outputs.values()))
	templates = set()
	for value in Outputs.values():
		for template in value:
			if template[1] == min_evalue:
				templates.add(template[0])

	return templates

def DownloadTemplate(template):
	"""
	Downloads the desired template from the pdb database. 

	Arguments:

	template: pdb code of the template to download.
	"""

	pdbl = PDBList()
	pdbl.retrieve_pdb_file(template, obsolete=False, pdir="./", file_format="pdb")

def FindInteractions(PDB_obj, inter):
	"""
	Find interactions or clashes between chains.

	Arguments:

	PDB_obj: PDB object in which we want to find interactions or clashes.
	inter: set to True if you want to find interactions. Set to False if you want to find clashes.
	"""

	if inter:
		interact_chains = []
		dist = 5.0
	else:
		dist = 0.4

	chains = Selection.unfold_entities(PDB_obj, 'C')
	obj_atoms = Selection.unfold_entities(PDB_obj, 'A')
	neighbors = NeighborSearch(obj_atoms)

	for chain in chains:
		atoms = Selection.unfold_entities(chain, 'A')
		for center in atoms: # For each atom as the center to compare distance to.
			interactions = neighbors.search(center.coord, dist ,level='C')
			if inter:
				ids = list(map(lambda x: x.get_id(), interactions))
				if len(ids) > 1:
					final_ids = list(filter(lambda x: x != chain.get_id(), ids))
					interact_chains.append((chain.get_id(), final_ids))
			else:
				for interact in interactions:
					if interact.get_id() != chain.get_id(): # If there is a clash between two diferent chains.
						return True
					else:
						continue
				return False
	if inter:
		return interact_chains

def AssignQueryToTemp(i, cand_list, temp_chains, Final_interactions, temp):
	"""
	Performs backtracking to assign each chain of the template to a chain of the target, taking into account 
	the similarities between template-target chains and, as a condition, that
	if two chains from the target interact, the two assigned chains from the template must also interact.

	Arguments:

	i: index of the recursivity. corresponding to the index of the target chains that is being assigned.
	cand_list: list of candidates (similarityes between template-target chains), 
		the list contains tupples where the first element is one chain and the second element is alist of candidates for this chain.
	temp_chains: dictionary of each chain of each template as keys and None as values at the beginnint,
		corresponding target chains will be saved in this dictionary.
	Final_interactions: dictionary containing the equivalencies between target-template chains, the target interactions and the template interactions.
	temp: name of the actual tempalte.
	"""

	j = 0

	if i >= len(cand_list):
		return True
	else:
		targ = cand_list[i][0]
		while j < len(cand_list[i][1]):
			valid = True
			# Check if the actual template chain has not any target chain assigned yet.
			if temp_chains[cand_list[i][1][j]] == None: 
				temp_chains[cand_list[i][1][j]] = targ
				for prev_temp in temp_chains.keys():
					# In a target chain has previously been assigned.
					if temp_chains[prev_temp] != None and temp_chains[prev_temp] != targ:
						# If both target chains interact.
						if GeneralFunctions.GetChain(targ) in GeneralFunctions.GetTargInteractionKeys(Final_interactions) and GeneralFunctions.GetChain(temp_chains[prev_temp]) in GeneralFunctions.GetTargInteractionKeys(Final_interactions): 
							if GeneralFunctions.GetChain(temp_chains[prev_temp]) in GeneralFunctions.GetTargetInteractions(Final_interactions, targ) or GeneralFunctions.GetChain(targ) in GeneralFunctions.GetTargetInteractions(Final_interactions, temp_chains[prev_temp]):
								# Both template chains must interact.
								if GeneralFunctions.GetChain(prev_temp) in GeneralFunctions.GetTempInteractionKeys(Final_interactions, temp):
									if GeneralFunctions.GetChain(cand_list[i][1][j]) not in GeneralFunctions.GetTempInteractions(Final_interactions, prev_temp, temp):
										valid = False
										break
								else: # Template chains do not interact.
									valid = False
									break
						elif GeneralFunctions.GetChain(targ) in GeneralFunctions.GetTargInteractionKeys(Final_interactions):
							if GeneralFunctions.GetChain(temp_chains[prev_temp]) in GeneralFunctions.GetTargetInteractions(Final_interactions, targ):
								# Both template chains must interact.
								if GeneralFunctions.GetChain(prev_temp) in GeneralFunctions.GetTempInteractionKeys(Final_interactions, temp):
									if GeneralFunctions.GetChain(cand_list[i][1][j]) not in GeneralFunctions.GetTempInteractions(Final_interactions, prev_temp, temp):
										valid = False
										break
								else: # Template chains do not interact.
									valid = False
									break
						elif GeneralFunctions.GetChain(temp_chains[prev_temp]) in GeneralFunctions.GetTargInteractionKeys(Final_interactions):
							if GeneralFunctions.GetChain(targ) in GeneralFunctions.GetTargetInteractions(Final_interactions, temp_chains[prev_temp]):
								# Both template chains must interact.
								if GeneralFunctions.GetChain(prev_temp) in GeneralFunctions.GetTempInteractionKeys(Final_interactions, temp):
									if GeneralFunctions.GetChain(cand_list[i][1][j]) not in GeneralFunctions.GetTempInteractions(Final_interactions, prev_temp, temp):
										valid = False
										break
								else: # Template chains do not interact.
									valid = False
									break
						else: # Template chains do not interact.
							valid = False
							break

				if valid:
					# Next recursive call
					if AssignQueryToTemp(i+1, cand_list, temp_chains, Final_interactions, temp):
						return True
				# The target chain is not well assigned so it must be emptied.		
				temp_chains[cand_list[i][1][j]] = None
			
			j += 1		
		return False

def I_AssignQueryToTemp(targ_chain_list, temp_chains, Final_interactions, temp):
	"""
	Performs an inmersion and performs the first recursive call.
	Assigns a list of candidate template chains to each target chain.

	Arguments:

	targ_chain_list: list of target chain names.
	temp_chains: dictionary of each chain of each template as keys and None as values at the beginnint,
		corresponding target chains will be saved in this dictionary.
	Final_interactions: dictionary containing the equivalencies between target-template chains, the target interactions and the template interactions.
	temp: name of the actual tempalte.
	"""

	candidates = []
	temporal_cand = []

	# Crates a list of tuples (string, list of candidates).
	for target in targ_chain_list:
		for template in Final_interactions["temps"][temp]["target_temp"].keys():
			if target in Final_interactions["temps"][temp]["target_temp"][template]:
				temporal_cand.append(template)
		candidates.append((target, temporal_cand))
		if temporal_cand != []:
			temporal_cand = []
		else:
			return

	# First recursive call.
	AssignQueryToTemp(0, candidates, temp_chains, Final_interactions, temp)

def SuperimposeChains(final_files, temp_obj, PDB_bychain_objects, temp_chains):
	"""
	Superimposes each target chain atoms to the corresponding template chain atoms.

	Arguments:

	temp_obj: object of the current template.
	PDB_bychain_objects: list of PDB objects corresponding to each target chain.
	temp_chains: dictionary with the correspondencies of template-target chains.
	"""

	i = 0
	ref_model = temp_obj[0]
	ppbuild = PPBuilder()
	template_chains = Selection.unfold_entities(temp_obj, 'C')
	min_len1 = min(list(map(lambda x: len(ppbuild.build_peptides(x)[0].get_sequence()), template_chains)))
	min_len2 = min(list(map(lambda x: len(ppbuild.build_peptides(x)[0].get_sequence()), PDB_bychain_objects)))
	min_len = min([min_len1, min_len2])
	atoms_to_be_aligned = range(2, min_len)

	# Perform the superimposition for each target chain.
	for sample_structure in PDB_bychain_objects:
		sample_model = sample_structure[0]
		ref_atoms = []
		sample_atoms = []

		# Superimpose the target chain with it's corresponding template chain.
		for ref_chain in ref_model:
			for key, val in temp_chains.items():
				if val == sample_structure.get_id():
					if GeneralFunctions.GetNameWOChain(key) == temp_obj.get_id():
						temp_ch = key
			if temp_obj.get_id() + "_" + ref_chain.get_id() == temp_ch:
				for ref_res in ref_chain:
					if ref_res.get_id()[1] in atoms_to_be_aligned: # Ensure to superimpose the same number of atoms.
						ref_atoms.append(ref_res['CA']) # Take only C-alfa atoms.

		for sample_chain in sample_model:
			for sample_res in sample_chain:
				if sample_res.get_id()[1] in atoms_to_be_aligned: # Ensure to superimpose the same number of atoms.
					sample_atoms.append(sample_res['CA']) # Take only C-alfa atoms.

		# Superimpose.
		super_imposer = Superimposer()
		super_imposer.set_atoms(ref_atoms, sample_atoms)
		matrix = super_imposer.rotran

		# Apply rotation and translation.
		for atom in sample_structure.get_atoms():
			atom.transform(matrix[0], matrix[1])

		# Create a PDB file to save the new coordinates.
		io = PDBIO()
		io.set_structure(sample_structure)
		io.save(temp_obj.get_id() + "_" + str(i) + "_aligned.pdb", write_end = False)
		i += 1

	# Append each chain to a unique file.
	j = copy.copy(i)
	i = 1
	file = open(temp_obj.get_id() + "_0_aligned.pdb", 'a')
	final_files.append(temp_obj.get_id() + "_0_aligned.pdb")

	while i < j:
		file2 = open(temp_obj.get_id() + "_" + str(i) + "_aligned.pdb")
		for line in file2:
			file.write(line)
		i += 1
